import Airtable from 'airtable';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';

import { SongFileSchema } from '../schemas/songs';

const outputDir = path.join(__dirname, '..');
const songFilePath = path.join(outputDir, 'songs.ts');

const fileHeader = /* ts */ `// Do not edit. This file was generated by scripts/update-songs.ts
import { SongFile } from './schemas/songs';
export default `;
const fileFooter = /* ts */ ` satisfies SongFile`;

console.log('üéµ Fetching songs...');

// load .env file
dotenv.config();

// get those songs
async function updateSongs() {
  try {
    const base = new Airtable({ apiKey: process.env.AIRTABLE_TOKEN }).base('appW24b09D9VHYHfi');
    const songs = await base('Dainorelis')
      .select({
        view: 'Songs',
        fields: ['Song', 'Lyrics', 'Source', 'Genre', 'Recommended key', 'Music author', 'Text author', 'YouTube'],
      })
      .all();

    const songFile = songs.map(({ id, fields }) => ({ id, fields }));
    const validSongFile = SongFileSchema.parse(songFile);

    // Write the song file
    fs.writeFileSync(songFilePath, fileHeader + JSON.stringify(validSongFile, null, 2) + fileFooter);
    console.log('‚úÖ Songs fetched and saved to songs.ts');
  } catch (e) {
    console.error('‚ùå Error fetching songs.', e);
    console.log('\n‚ÑπÔ∏è  Falling back to saved songs');
  }
}

updateSongs();

// todo: figure out exactly how inefficient it is to load all the songs in a single file
