import Airtable, { FieldSet, Records } from 'airtable';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';

import { Song, SongFile, SongFileSchema } from '../lib/schemas/songs';

const fieldFlags: Record<keyof Song['fields'], boolean> = {
  Name: true,
  Lyrics: true,
  Videos: false,
  Audio: false,
  PDFs: false,
  Tags: false,
  Sources: false,
  'Recommended Key': false,
  'Music Author': true,
  'Text Author': true,
  'LT Description': false,
  'EN Description': false,
} as const;

const outputDir = path.join(__dirname, '..');
const songFilePath = path.join(outputDir, 'songs.ts');

const fileHeader = /* ts */ `// Do not edit. This file was generated by scripts/update-songs.ts

import { SongFile } from '@/lib/schemas/songs';

const songs: SongFile = `;

const fileFooter = /* ts */ `

export default songs`;

console.log('üéµ Fetching songs...');

// load .env file
dotenv.config();

// get ready!
const base = new Airtable({ apiKey: process.env.AIRTABLE_TOKEN }).base('appW24b09D9VHYHfi');

// get set!
async function getSongs() {
  return await base('Songs')
    .select({
      view: 'Grid view',
      fields: [
        'Name',
        'Lyrics',
        'Videos',
        'Audio',
        'PDFs',
        'Tags',
        'Sources',
        'Recommended Key',
        'Music Author',
        'Text Author',
        'LT Description',
        'EN Description',
      ],
      sort: [{ field: 'Name', direction: 'asc' }],
    })
    .all();
}
async function getLyrics() {
  return await base('Lyrics & Chords')
    .select({
      view: 'Grid view',
      fields: ['Variant Name', 'Lyrics & Chords', 'Show Chords'],
    })
    .all();
}
async function getVideos() {
  return await base('Videos')
    .select({
      view: 'Grid view',
      fields: ['Variant Name', 'YouTube Link'],
    })
    .all();
}
// todo: mirror to r2 storage
async function getAudio() {
  return await base('Audio')
    .select({
      view: 'Grid view',
      fields: ['Variant Name', 'File'],
    })
    .all();
}
// todo: mirror to r2 storage
async function getPDFs() {
  return await base('PDFs')
    .select({
      view: 'Grid view',
      fields: ['Variant Name', 'File'],
    })
    .all();
}

function getRecordsForField(field: FieldSet[string], records: Records<FieldSet>): FieldSet[string] | FieldSet[] {
  if (!Array.isArray(field)) return field;

  return field
    .map((id) => {
      if (typeof id !== 'string') return null;
      const record = records.find((record) => record.id === id);
      if (!record) return null;
      return record.fields;
    })
    .filter((r) => r !== null);
}

/**
 * When `Variant Name` is not defined, we default to `Variantas ${idx + 1}`
 */
function assignVariantNames(records: FieldSet[string] | FieldSet[], prefix: string, startIdx = 0) {
  if (!Array.isArray(records)) return records;
  return records.map((record, idx) => ({
    ...record,
    'Variant Name': record['Variant Name'] ?? `${prefix} ${startIdx + idx + 1}`,
  }));
}

// get those songs
async function updateSongs() {
  try {
    const [songs, lyrics, videos, audio, pdfs] = await Promise.all([
      getSongs(),
      getLyrics(),
      getVideos(),
      getAudio(),
      getPDFs(),
    ]);

    const songFile = songs.map((song) => {
      const Lyrics = assignVariantNames(getRecordsForField(song.fields.Lyrics, lyrics), 'Variantas');
      const lyricCount = Array.isArray(Lyrics) ? Lyrics.length : 0;
      const PDFs = assignVariantNames(getRecordsForField(song.fields.PDFs, pdfs), 'Variantas', lyricCount);

      const Audio = assignVariantNames(getRecordsForField(song.fields.Audio, audio), 'ƒÆra≈°as');
      const audioCount = Array.isArray(Audio) ? Audio.length : 0;
      const Videos = assignVariantNames(getRecordsForField(song.fields.Videos, videos), 'ƒÆra≈°as', audioCount);

      return {
        id: song.id,
        fields: {
          ...song.fields,
          Lyrics,
          Videos,
          Audio,
          PDFs,
        },
      };
    });
    const validSongFile = SongFileSchema.parse(songFile);
    const filteredSongFile = validSongFile.map((song) => {
      return {
        id: song.id,
        fields: Object.fromEntries(
          Object.entries(song.fields).filter(([key]) => fieldFlags[key as keyof Song['fields']])
        ),
      };
    }) as SongFile;

    // Write the song file
    fs.writeFileSync(songFilePath, fileHeader + JSON.stringify(filteredSongFile, null, 2) + fileFooter);
    console.log('‚úÖ Songs fetched and saved to songs.ts');
    console.log(
      Object.entries(fieldFlags)
        .map(([key, value]) => `  - ${value ? 'Enabled  ' : 'Disabled '} ${key}`)
        .join('\n')
    );
  } catch (e) {
    console.error('‚ùå Error fetching songs.', e);
    console.log('\n‚ÑπÔ∏è  Falling back to saved songs');
  }
}

updateSongs();
