import Airtable, { FieldSet, Records } from 'airtable';
import dotenv from 'dotenv';
import fs from 'fs';
import Fuse from 'fuse.js';
import path from 'path';
import removeMd from 'remove-markdown';

import { Song, SongFile, SongFileSchema } from '../lib/schemas/songs';

const fieldFlags: Record<keyof Song['fields'], boolean> = {
  Name: true,
  Lyrics: true,
  Videos: false,
  Audio: true,
  PDFs: true,
  Translations: true,
  Tags: false,
  Sources: false,
  'Recommended Key': false,
  'Music Author': true,
  'Text Author': true,
  'LT Description': true,
  'EN Description': true,
  'AI-Generated Description': true,
} as const;

const outputDir = path.join(__dirname, '..');
const songFilePath = path.join(outputDir, 'songs.ts');
const songFestivalFilePath = path.join(outputDir, 'song-festival.ts');
const titleIndexFilePath = path.join(outputDir, 'title-index.json');
const lyricIndexFilePath = path.join(outputDir, 'lyric-index.json');

const fileHeader = /* ts */ `// Do not edit. This file was generated by scripts/update-songs.ts

import { SongFile } from '@/lib/schemas/songs';

const songs: SongFile = `;

const fileFooter = /* ts */ `

export default songs`;

console.log('🎵 Fetching songs...');

// load .env file
dotenv.config();

// get ready!
const base = new Airtable({ apiKey: process.env.AIRTABLE_TOKEN }).base('appW24b09D9VHYHfi');

// get set!
async function getSongs() {
  return await base('Songs')
    .select({
      view: 'Grid view',
      fields: [
        'Name',
        'Lyrics',
        'Videos',
        'Audio',
        'PDFs',
        'Translations',
        'Tags',
        'Sources',
        'Recommended Key',
        'Music Author',
        'Text Author',
        'LT Description',
        'EN Description',
      ],
      sort: [{ field: 'Name', direction: 'asc' }],
      filterByFormula: 'NOT(Hide)',
    })
    .all();
}
async function getLyrics() {
  return await base('Lyrics & Chords')
    .select({
      view: 'Grid view',
      fields: ['Variant Name', 'EN Variant Name', 'Lyrics & Chords', 'Show Chords', 'Notes'],
    })
    .all();
}
async function getVideos() {
  return await base('Videos')
    .select({
      view: 'Grid view',
      fields: ['Variant Name', 'EN Variant Name', 'YouTube Link'],
    })
    .all();
}
async function getAudio() {
  return await base('Audio')
    .select({
      view: 'Grid view',
      fields: ['Variant Name', 'EN Variant Name', 'URL', 'Album', 'Artist'],
    })
    .all();
}
async function getPDFs() {
  return await base('PDFs')
    .select({
      view: 'Grid view',
      fields: ['Variant Name', 'EN Variant Name', 'URL'],
    })
    .all();
}
async function getTranslations() {
  return await base('Translations')
    .select({
      view: 'Grid view',
      fields: ['Title', 'Variant Name', 'EN Variant Name', 'Lyrics', 'AI Generated', 'Notes'],
    })
    .all();
}

function getRecordsForField(field: FieldSet[string], records: Records<FieldSet>): FieldSet[string] | FieldSet[] {
  if (!Array.isArray(field)) return field;

  return field
    .map((id) => {
      if (typeof id !== 'string') return null;
      const record = records.find((record) => record.id === id);
      if (!record) return null;
      return record.fields;
    })
    .filter((r) => r !== null);
}

/**
 * When `Variant Name` is not defined, we default to `${defaultName} ${idx + 1}`
 * When `EN Variant Name` is not defined, we default to `Variant Name`
 */
function assignVariantNames(records: FieldSet[string] | FieldSet[], defaultLtName: string, defaultEnName: string) {
  if (!Array.isArray(records)) return records;
  const numberOfMissingVariantNames = records.filter((record) => !record['Variant Name']).length;
  const shouldAppendIndexNumber = numberOfMissingVariantNames > 1;

  return records.map((record, idx) => {
    const alreadyHasName = !!record['Variant Name'];
    let ltName = alreadyHasName ? record['Variant Name'] : defaultLtName;
    let enName = alreadyHasName ? (record['EN Variant Name'] ?? record['Variant Name']) : defaultEnName;
    if (shouldAppendIndexNumber && !alreadyHasName) {
      ltName += ` ${idx + 1}`;
      enName += ` ${idx + 1}`;
    }
    return {
      ...record,
      'Variant Name': ltName,
      'EN Variant Name': enName,
    };
  });
}

/**
 * Throughout lyrics, the pattern [space](Chord) is frequently used
 * Since that's often not enough space, we do a lil magic to fix it up a bit
 * Based on the number of wide characters in the chord, we add that many em spaces (Max 4)
 * E.g., [space](C) => [emspace](C)
 *       [space](C#) => [emspace emspace](C#)
 *       [space](C/D) => [emspace emspace](C/D)
 *       [space](C#maj7) => [emspace emspace emspace ](C#maj7)
 */
function adjustChordWhitespace(lyrics: FieldSet[string] | FieldSet[]) {
  const emSpace = ' ';
  const wideCharRegex = /[a-zA-Z0-9#]/g; // Only count alphanumeric and "#" as wide characters
  if (!Array.isArray(lyrics)) return lyrics;
  return lyrics.map((record) => {
    const lyricsText = record['Lyrics & Chords'];
    if (typeof lyricsText !== 'string') return record;

    const adjustedLyrics = lyricsText.replace(/\[\s*\]\(([^\)]+)\)/g, (match, chord) => {
      // Count wide characters in the chord
      const wideCount = (chord.match(wideCharRegex) || []).length;
      const emSpaces = emSpace.repeat(Math.min(3, wideCount));
      return `[${emSpaces}](${chord})`;
    });

    return {
      ...record,
      'Lyrics & Chords': adjustedLyrics,
    };
  });
}

// get those songs
async function updateSongs() {
  try {
    const [songs, lyrics, videos, audio, pdfs, translations] = await Promise.all([
      getSongs(),
      getLyrics(),
      getVideos(),
      getAudio(),
      getPDFs(),
      getTranslations(),
    ]);

    const songFile = songs.map((song) => {
      const Lyrics = adjustChordWhitespace(
        assignVariantNames(getRecordsForField(song.fields.Lyrics, lyrics), 'Žodžiai', 'Lyrics')
      );
      const PDFs = assignVariantNames(getRecordsForField(song.fields.PDFs, pdfs), 'Natos', 'Score');
      const Audio = assignVariantNames(getRecordsForField(song.fields.Audio, audio), 'Įrašas', 'Recording');
      const Videos = assignVariantNames(getRecordsForField(song.fields.Videos, videos), 'Įrašas', 'Recording');
      const Translations = assignVariantNames(
        getRecordsForField(song.fields.Translations, translations),
        'Vertimas',
        'Translation'
      );

      return {
        id: song.id,
        fields: {
          ...song.fields,
          Lyrics,
          Videos,
          Audio,
          PDFs,
          Translations,
        },
      };
    });
    const validSongFile = SongFileSchema.parse(songFile);
    const filteredSongFile = validSongFile.map((song) => {
      return {
        id: song.id,
        fields: Object.fromEntries(
          Object.entries(song.fields).filter(([key]) => fieldFlags[key as keyof Song['fields']])
        ),
      };
    }) as SongFile;

    // Write the song file
    fs.writeFileSync(songFilePath, fileHeader + JSON.stringify(filteredSongFile, null, 2) + fileFooter);
    console.log('✅ Songs fetched and saved to songs.ts');
    console.log(
      Object.entries(fieldFlags)
        .map(([key, value]) => `  - ${value ? 'Enabled  ' : 'Disabled '} ${key}`)
        .join('\n')
    );

    // now do the song festival
    const songFestivalFileHeader = /* ts */ `// Do not edit. This file was generated by scripts/update-ts

const songFestival = `;

    const songFestivalFileFooter = /* ts */ `

export default songFestival`;

    const songFestivalList = [
      {
        title: 'songFestivalRepertoire0',
        data: [
          filteredSongFile.findIndex((song) => song.fields.Name === 'JAV Himnas (The Star Spangled Banner)'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Kanados himnas (O Canada)'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Lietuvos himnas (Tautiška giesmė)'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Baltas paukštis'),
        ],
      },
      {
        title: 'songFestivalRepertoire1',
        data: [
          filteredSongFile.findIndex((song) => song.fields.Name === 'Lietuviais esame mes gimę'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Čiūto'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Buvo dūda Vilniuj'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Dzūkit, dzūkit girnelės'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Ir įšoko ožėlis'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Ne dėl žalio vyno'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Už Raseinių'),
        ],
      },
      {
        title: 'songFestivalRepertoire2',
        data: [
          filteredSongFile.findIndex((song) => song.fields.Name === 'Pienės pūkas'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Ar žinai tu, klajūne, keleivi'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Žąsinas'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Skaičiuotės'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Aš pasėjau linelį'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Jau saulutė leidžias'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Jonvabalis'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Greitai, greitai'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Šią naktelę, per naktelę'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Tai manoji Lietuva'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Greitakalbės'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Ten mano svajos'),
        ],
      },
      {
        title: 'songFestivalRepertoire3',
        data: [
          filteredSongFile.findIndex((song) => song.fields.Name === 'Užaugo liepa'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Beauštanti aušrelė'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Kur sakalalis'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Cykiai, cykiai'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Žmonės ant kalnų'),
        ],
      },
      {
        title: 'songFestivalRepertoire4',
        data: [
          filteredSongFile.findIndex((song) => song.fields.Name === 'Kraičio drobelės'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Pradės aušrelė aušti'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Žvirbliai'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Šarkela varnela'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Kalvelis'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Džigūnas'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Kupolinis'),
          filteredSongFile.findIndex((song) => song.fields.Name === 'Viena šeima, viena tauta'),
        ],
      },
    ];

    // if any data is missing, throw an error
    if (songFestivalList.some((section) => section.data.some((index) => index === -1))) {
      console.error(JSON.stringify(songFestivalList, null, 2));
      throw new Error('Some songs are missing from the song festival list');
    }
    // otherwise, write the song festival file
    fs.writeFileSync(
      songFestivalFilePath,
      songFestivalFileHeader + JSON.stringify(songFestivalList, null, 2) + songFestivalFileFooter
    );
    console.log('✅ Song festival list created and saved to song-festival.ts');

    // create search index
    const filteredSongFileWithoutMarkdown = filteredSongFile.map((song) => ({
      ...song,
      fields: {
        ...song.fields,
        Lyrics: song.fields.Lyrics.map((variant) => ({
          ...variant,
          'Lyrics & Chords': removeMd(variant['Lyrics & Chords']),
        })),
      },
    }));

    const titleIndex = Fuse.createIndex([{ name: 'name', getFn: (s) => s.fields.Name }], filteredSongFile);
    const lyricIndex = Fuse.createIndex([['fields', 'Lyrics', 'Lyrics & Chords']], filteredSongFileWithoutMarkdown);
    fs.writeFileSync(titleIndexFilePath, JSON.stringify(titleIndex));
    fs.writeFileSync(lyricIndexFilePath, JSON.stringify(lyricIndex));
    console.log('✅ Search indices created and saved to title-index.json and lyric-index.json');
  } catch (e) {
    console.error('❌ Error fetching & indexing songs.', e);
    console.log('\nℹ️  Falling back to saved songs');
  }
}

updateSongs();
